"use strict";let dirCache = require('dir_cache');let myUtil = require('utils-igor')(['type','obj', 'arr']);let cacheOptions = {};let cacheTemplate = {};let mainLayout = '';let log = {error : myUtil.type.noop,info : myUtil.type.noop,warn : myUtil.type.noop,err : myUtil.type.noop};exports.load = (options, cb) => {cb = myUtil.type.beFn(cb);let controllers = {};let reinfo = {};let dirs = [options.path];if (options.loadDefaults) {dirs.push({path : __dirname + '/../default-pages'});}dirCache.required({isCall : false,dirs : dirs,exts : ['.js']}, (e, scan) => {if (e) return cb(e);scan.run((e, scan) => {if (e) return cb(e);myUtil.obj.each(scan.res.cache, (name, module) => {if (!myUtil.type.isFn(module)) return;let info = module();if (myUtil.type.isObj(info)) {myUtil.obj.ext(controllers, info);myUtil.obj.each(info, (r) => reinfo[r] = module);}});myUtil.obj.each(controllers, (name, config) => {controllers[name] = myUtil.obj.ext({title: '',route: name,showTitle: true,showInMenu: true,parentMenu: '/',order: 5,count: 0,groups: 'all',url: (options.baseUrl + '/' + name),note: '',active: 0}, config);options.menu.push(controllers[name]);});options.menu.sort((a, b) => a.order > b.order ? 1 : (a.order < b.order ? -1 : 0) );exports.add(options, controllers);options.reinfo ? myUtil.obj.ext(options.reinfo, reinfo) : options.reinfo = reinfo;cb();});});};if (process.env.debugRouter) {let winston = require('winston');log = new winston.Logger({transports: [new winston.transports.Console({level: 'debug',handleExceptions: true,json: false,colorize: true})],exitOnError: false});log.err = log.error;}exports.loadTemplate = (router, cb) => {dirCache.swig({ dirs : cacheOptions.fullViews },(e, collected) => {if (e) return cb(e);collected.run((e, scan) => {if (e) return cb(e);if (!mainLayout) mainLayout = scan.res.cache.index;delete scan.res.cache.index;cacheTemplate = scan.res.cache;cb();});});};exports.addRouters = (router, app, cb) => {cacheOptions = router.options;exports.loadTemplate(router, (e) => {if (e) return cb(e);log.info('Load template suceess');app.use(exports.baseUrl(), (req, res, next) => {(req.options) ?myUtil.obj.ext(req.options, mainOption) :myUtil.obj.ext(req, {options: myUtil.obj.ext({}, cacheOptions)});req.options.log = log;log.info('Attach option to req');next();});let auth = require('./auth');app.use(exports.baseUrl('auth'), auth.render);app.use(exports.baseUrl(':module'), auth.test, exports.handelModule);app.use(exports.baseUrl(), auth.test, (req, res) => res.redirect(exports.baseUrl('home')));cb();});};exports.isStatic = (req) => !req.originalUrl.length || req.originalUrl.substr(0,req.options.staticUrl.length) === req.options.staticUrl;exports.handelModule = (req, res, next) => {if (exports.isStatic(req)) return next();log.info( 'Start get module ' + req.params.module);if (req.params.module === 'auth') return res.redirect('home');let module = req.options.modules[req.params.module];if (module && myUtil.type.isFn(module.method) ) {log.info( 'Module ' + req.params.module + ' find');if (!module.noDefLayout) {log.info( 'Change render ');res.render = (view, options, callback)=> {res.req.options.log.info(`Process view ${view}`);if (options && options.noDef)return res.render(view, options, callback);if (myUtil.type.isFn(options)) {callback = options;options = {};}let content = cacheTemplate[view] || null;if (!content)return res.render(view, options, callback);content = mainLayout.replace('{{ content }}', content);options = options || {};options = myUtil.obj.ext(options, res.req.options);options.login = options.login ||(res.req &&req.res.cookies &&req.res.cookies.login? req.res.cookies.login: null);options = exports.renderData(res, options);content = cacheOptions.require.swig.render(content,{ locals: options } );if (myUtil.type.isFn(callback))return callback(null, content);res.send(content);};}exports.handelOption(req, res, next);} else {log.warn( 'Module ' + req.params.module + ' 404');res.redirect(exports.baseUrl('404'));}};exports.handelOption = (req, res, next, cb) => {let page = req.options.modules[req.params.module];let user = req.options.user || false;let u = user ? req.options.users[user.login] : {upd: 0};let updated = false;if (page && page.tabs) {let firstTab;let activeTab;myUtil.obj.each(page.tabs, (tabKey) => {firstTab = firstTab || tabKey;if (tabKey === 'default' && !activeTab)activeTab = 'default';if (req.query.tab && tabKey === req.query.tab)activeTab = tabKey;});page.activeTab = activeTab || firstTab;}if (user || req.options.noAuth) {let sec = parseInt(Date.now() / 1000, 10);if (!u.upd || Number(u.upd) !== sec) {u.upd = sec;req.options.menu.forEach(function (el, i) {let info = req.options.reinfo[req.options.menu[i].route](req.options.noAuth ? false : user);exports.add(req.options, info);});}updated = true;}req.options.page = page || { groups : ''};req.current = page;let iterMap = (el) => String(el.trim());req.options.page.groups = req.options.page.groups || '';let pg = req.options.page.groups.split(',').map(iterMap);let ug = (user && user.groups) ? user.groups.split(',').map(iterMap) : [];ug.push('all');if (user && user.groups)req.options.menu = req.options.menu.filter((el) => {if (!el.groups) return false;let g = el.groups.split(',').map(iterMap);if (!exports.arrayTest(ug, g).length)el.showInMenu = false;return true;});if (!exports.arrayTest(ug, pg).length) {log.warn('Access denied ', 'user', ug,'page', pg);return res.redirect(exports.baseUrl('access-denied'));}req.options.menu.forEach(function (el, i) {if (updated) myUtil.obj.ext(req.options.menu[i], req.options.modules[req.options.menu[i].r]);el.active = exports.baseUrl(page.route.toLowerCase()) === el.url.toLowerCase();});let submenus = {};req.options.menu.forEach((el, i) => {if (!el.submenu || !el.submenu.length) return;if (!submenus[el.submenu])submenus[el.submenu] = {items : [],order : 1};let sub = submenus[el.submenu];sub.items.push(el);if (el.subOrder)sub.order = el.subOrder;if (el.active)sub.open = true;req.options.menu[i].showInMenu = false;});req.options.submenus = sortByProp(submenus, 'order');let p = req.path.replace(req.options.page.url + '/', '').split('/');myUtil.obj.ext(req.params, p);req.length = p.length;if (myUtil.type.isFn(cb)) return cb();page.method(req, res, next);};exports.renderData = (req, data) => myUtil.obj.ext({staticUrl: cacheOptions.staticUrl,baseUrl : cacheOptions.baseUrl,content : '',title : '',isProd : process.env.NODE_ENV !== 'dev',login: req.cookies && req.cookies.login ? req.cookies.login : '',menu : cacheOptions.menu || {}},myUtil.obj.isEmpty(data) ? {} : data);let sortByProp = (obj, prop) => {let sortObj = {};let after = {};let r = {};myUtil.obj.each(obj, (key, el) => {if (!el[prop]) {after[key] = el;return;}let k = el[prop];sortObj[k] = sortObj[k] || {};sortObj[k][key] = el;});myUtil.obj.each(sortObj, (k, el) => myUtil.obj.each(el, (k, val) => r[k] = val), myUtil.arr.sortNumber);return myUtil.obj.ext(r, after);};exports.add = (options, obj) => {if (myUtil.type.isObj(obj) )(options.modules)? myUtil.obj.each(obj, (nm, el) => options.modules[nm] ? myUtil.obj.ext(options.modules[nm], el) : options.modules[nm] = el): options.modules = obj;};exports.arrayTest = (arr1, arr2) => arr1.filter((i) => ~arr2.indexOf(i) );exports.baseUrl = (attach) => cacheOptions.baseUrl + '/' + (attach || '' );